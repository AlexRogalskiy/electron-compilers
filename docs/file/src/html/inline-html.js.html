<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/html/inline-html.js | electron-compilers API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/paulcbetts/electron-compilers" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/compiler-base.js~SimpleCompilerBase.html">SimpleCompilerBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/compiler-base.js~CompilerBase.html">CompilerBase</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/html/inline-html.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import _ from &apos;lodash&apos;;
import path from &apos;path&apos;;
import mimeTypes from &apos;mime-types&apos;;
import {CompilerBase} from &apos;../compiler-base&apos;;

const inputMimeTypes = [&apos;text/html&apos;];
let cheerio = null;

const d = require(&apos;debug&apos;)(&apos;electron-compile:inline-html&apos;);

/**
 * @access private
 */
export default class InlineHtmlCompiler extends CompilerBase {
  constructor(compileBlock, compileBlockSync) {
    super();

    this.compileBlock = compileBlock;
    this.compileBlockSync = compileBlockSync;
  }

  static createFromCompilers(compilersByMimeType) {
    d(`Setting up inline HTML compilers: ${JSON.stringify(Object.keys(compilersByMimeType))}`);

    let compileBlock = async (sourceCode, filePath, mimeType, ctx) =&gt; {
      let realType = mimeType;
      if (!mimeType &amp;&amp; ctx.tag === &apos;script&apos;) realType = &apos;application/javascript&apos;;

      if (!realType) return sourceCode;

      let compiler = compilersByMimeType[realType] || compilersByMimeType[&apos;text/plain&apos;];
      let ext = mimeTypes.extension(realType);
      let fakeFile = `${filePath}:inline_${ctx.count}.${ext}`;

      d(`Compiling inline block for ${filePath} with mimeType ${mimeType}`);
      if (!(await compiler.shouldCompileFile(fakeFile, ctx))) return sourceCode;
      return (await compiler.compileSync(sourceCode, fakeFile, ctx)).code;
    };

    let compileBlockSync = (sourceCode, filePath, mimeType, ctx) =&gt; {
      let realType = mimeType;
      if (!mimeType &amp;&amp; ctx.tag === &apos;script&apos;) realType = &apos;application/javascript&apos;;

      if (!realType) return sourceCode;

      let compiler = compilersByMimeType[realType] || compilersByMimeType[&apos;text/plain&apos;];
      let ext = mimeTypes.extension(realType);
      let fakeFile = `${filePath}:inline_${ctx.count}.${ext}`;

      d(`Compiling inline block for ${filePath} with mimeType ${mimeType}`);
      if (!compiler.shouldCompileFileSync(fakeFile, ctx)) return sourceCode;
      return compiler.compileSync(sourceCode, fakeFile, ctx).code;
    };

    return new InlineHtmlCompiler(compileBlock, compileBlockSync);
  }

  static getInputMimeTypes() {
    return inputMimeTypes;
  }

  async shouldCompileFile(fileName, compilerContext) {
    return true;
  }

  async determineDependentFiles(sourceCode, filePath, compilerContext) {
    return [];
  }

  async each(nodes, selector) {
    let acc = [];
    nodes.each((i, el) =&gt; {
      let promise = selector(i,el);
      if (!promise) return false;

      acc.push(promise);
      return true;
    });

    await Promise.all(acc);
  }

  eachSync(nodes, selector) {
    // NB: This method is here just so it&apos;s easier to mechanically
    // translate the async compile to compileSync
    return nodes.each((i,el) =&gt; {
      selector(i,el);
      return true;
    });
  }

  async compile(sourceCode, filePath, compilerContext) {
    cheerio = cheerio || require(&apos;cheerio&apos;);
    let $ = cheerio.load(sourceCode);
    let toWait = [];

    let that = this;
    let styleCount = 0;
    toWait.push(this.each($(&apos;style&apos;), async (i, el) =&gt; {
      let mimeType = $(el).attr(&apos;type&apos;) || &apos;text/plain&apos;;

      let thisCtx = _.assign({
        count: styleCount++,
        tag: &apos;style&apos;
      }, compilerContext);

      $(el).text(await that.compileBlock($(el).text(), filePath, mimeType, thisCtx));
      $(el).attr(&apos;type&apos;, &apos;text/css&apos;);
    }));

    let scriptCount = 0;
    toWait.push(this.each($(&apos;script&apos;), async (i, el) =&gt; {
      let src = $(el).attr(&apos;src&apos;);
      if (src &amp;&amp; src.length &gt; 2) {
        $(el).attr(&apos;src&apos;, InlineHtmlCompiler.fixupRelativeUrl(src));
        return;
      }

      let thisCtx = _.assign({
        count: scriptCount++,
        tag: &apos;script&apos;
      }, compilerContext);

      let mimeType = $(el).attr(&apos;type&apos;) || &apos;application/javascript&apos;;

      $(el).text(await that.compileBlock($(el).text(), filePath, mimeType, thisCtx));
      $(el).attr(&apos;type&apos;, &apos;application/javascript&apos;);
    }));

    $(&apos;link&apos;).map((i, el) =&gt; {
      let href = $(el).attr(&apos;href&apos;);
      if (href &amp;&amp; href.length &gt; 2) { $(el).attr(&apos;href&apos;, InlineHtmlCompiler.fixupRelativeUrl(href)); }
    });

    $(&apos;x-require&apos;).map((i, el) =&gt; {
      let src = $(el).attr(&apos;src&apos;);

      // File URL? Bail
      if (src.match(/^file:/i)) return;

      // Absolute path? Bail.
      if (src.match(/^([\/]|[A-Za-z]:)/i)) return;

      try {
        $(el).attr(&apos;src&apos;, path.resolve(path.dirname(filePath), src));
      } catch (e) {
        $(el).text(`${e.message}\n${e.stack}`);
      }
    });

    await Promise.all(toWait);

    return {
      code: $.html(),
      mimeType: &apos;text/html&apos;
    };
  }

  shouldCompileFileSync(fileName, compilerContext) {
    return true;
  }

  determineDependentFilesSync(sourceCode, filePath, compilerContext) {
    return [];
  }

  compileSync(sourceCode, filePath, compilerContext) {
    cheerio = cheerio || require(&apos;cheerio&apos;);
    let $ = cheerio.load(sourceCode);

    let that = this;
    let styleCount = 0;
    this.eachSync($(&apos;style&apos;), async (i, el) =&gt; {
      let mimeType = $(el).attr(&apos;type&apos;);

      let thisCtx = _.assign({
        count: styleCount++,
        tag: &apos;style&apos;
      }, compilerContext);

      $(el).text(that.compileBlockSync($(el).text(), filePath, mimeType, thisCtx));
      $(el).attr(&apos;type&apos;, &apos;text/css&apos;);
    });

    let scriptCount = 0;
    this.eachSync($(&apos;script&apos;), async (i, el) =&gt; {
      let src = $(el).attr(&apos;src&apos;);
      if (src &amp;&amp; src.length &gt; 2) {
        $(el).attr(&apos;src&apos;, InlineHtmlCompiler.fixupRelativeUrl(src));
        return;
      }

      let thisCtx = _.assign({
        count: scriptCount++,
        tag: &apos;script&apos;
      }, compilerContext);

      let mimeType = $(el).attr(&apos;type&apos;);

      $(el).text(that.compileBlockSync($(el).text(), filePath, mimeType, thisCtx));
      $(el).attr(&apos;type&apos;, &apos;application/javascript&apos;);
    });

    $(&apos;link&apos;).map((i, el) =&gt; {
      let href = $(el).attr(&apos;href&apos;);
      if (href &amp;&amp; href.length &gt; 2) { $(el).attr(&apos;href&apos;, InlineHtmlCompiler.fixupRelativeUrl(href)); }
    });

    $(&apos;x-require&apos;).map((i, el) =&gt; {
      let src = $(el).attr(&apos;src&apos;);

      // File URL? Bail
      if (src.match(/^file:/i)) return;

      // Absolute path? Bail.
      if (src.match(/^([\/]|[A-Za-z]:)/i)) return;

      try {
        $(el).attr(&apos;src&apos;, path.resolve(path.dirname(filePath), src));
      } catch (e) {
        $(el).text(`${e.message}\n${e.stack}`);
      }
    });

    return {
      code: $.html(),
      mimeType: &apos;text/html&apos;
    };
  }

  getCompilerVersion() {
    let thisVersion = require(&apos;../../package.json&apos;).version;
    let otherVersions = _.map(this.allCompilers, (x) =&gt; x.getCompilerVersion).join();

    return `${thisVersion},${otherVersions}`;
  }

  static fixupRelativeUrl(url) {
    if (!url.match(/^\/\//)) return url;
    return `https:${url}`;
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
